// -----------------------------------------------------------------------------------------------------
// Copyright (c) 2006-2020, Knut Reinert & Freie Universität Berlin
// Copyright (c) 2016-2020, Knut Reinert & MPI für molekulare Genetik
// This file may be used, modified and/or redistributed under the terms of the 3-clause BSD-License
// shipped with this file and also available at: https://github.com/seqan/seqan3/blob/master/LICENSE.md
// -----------------------------------------------------------------------------------------------------

/*!\file
 * \author Mitra Darvish <mitra.darvish AT fu-berlin.de>
 * \brief Edited by Evelin Aasna based on seqan3::views::minimiser to return a range of tuples (minimiser, start_positon)
 */

#pragma once

#include <seqan3/std/algorithm>
#include <deque>

#include <seqan3/core/detail/empty_type.hpp>
#include <seqan3/core/range/detail/adaptor_from_functor.hpp>
#include <seqan3/core/range/type_traits.hpp>
#include <seqan3/utility/range/concept.hpp>
#include <seqan3/utility/tuple/common_tuple.hpp>
#include <seqan3/utility/type_traits/lazy_conditional.hpp>

#include <seqan3/search/views/minimiser.hpp>

namespace valik
{
// ---------------------------------------------------------------------------------------------------------------------
// indexed_minimiser_view class
// ---------------------------------------------------------------------------------------------------------------------

/*!\brief The type returned by seqan3::views::minimiser.
 * \tparam urng1_t The type of the underlying range, must model std::ranges::forward_range, the reference type must
 *                 model std::totally_ordered. The typical use case is that the reference type is the result of
 *                 seqan3::kmer_hash.
 * \tparam urng2_t The type of the second underlying range, must model std::ranges::forward_range, the reference type
 *                 must model std::totally_ordered. If only one range is provided this defaults to
 *                 std::ranges::empty_view.
 * \implements std::ranges::view
 * \ingroup views
 *
 * \details
 *
 * See seqan3::views::minimiser for a detailed explanation on minimizers.
 *
 * \note Most members of this class are generated by std::ranges::view_interface which is not yet documented here.
 *
 */
template <std::ranges::view urng1_t,
          std::ranges::view urng2_t = std::ranges::empty_view<seqan3::detail::empty_type>>
class indexed_minimiser_view : public std::ranges::view_interface<indexed_minimiser_view<urng1_t, urng2_t>>
{
private:
    using minimiser_view_t = seqan3::detail::minimiser_view<urng1_t, urng2_t>;

    //!\brief Whether the given ranges are const_iterable
    static constexpr bool const_iterable = seqan3::const_iterable_range<minimiser_view_t>;

    template <bool const_range>
    class basic_iterator;

    //!\brief The sentinel type of the indexed_minimiser_view.
    using sentinel = std::default_sentinel_t;

    minimiser_view_t minimiser_view;

public:
    /*!\name Constructors, destructor and assignment
     * \{
     */
    indexed_minimiser_view() = default; //!< Defaulted.
    indexed_minimiser_view(indexed_minimiser_view const & rhs) = default; //!< Defaulted.
    indexed_minimiser_view(indexed_minimiser_view && rhs) = default; //!< Defaulted.
    indexed_minimiser_view & operator=(indexed_minimiser_view const & rhs) = default; //!< Defaulted.
    indexed_minimiser_view & operator=(indexed_minimiser_view && rhs) = default; //!< Defaulted.
    ~indexed_minimiser_view() = default; //!< Defaulted.

    /*!\brief Construct from a view and a given number of values in one window.
    * \param[in] urange1     The input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] window_size The number of values in one window.
    */
    indexed_minimiser_view(urng1_t urange1, size_t const window_size) :
        minimiser_view{std::move(urange1), window_size}
    {}

    /*!\brief Construct from a non-view that can be view-wrapped and a given number of values in one window.
    * \tparam other_urng1_t  The type of another urange. Must model std::ranges::viewable_range and be constructible
                             from urng1_t.
    * \param[in] urange1     The input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] window_size The number of values in one window.
    */
    template <typename other_urng1_t>
    //!\cond
        requires (std::ranges::viewable_range<other_urng1_t> &&
                  std::constructible_from<urng1_t, ranges::ref_view<std::remove_reference_t<other_urng1_t>>>)
    //!\endcond
    indexed_minimiser_view(other_urng1_t && urange1, size_t const window_size) :
        minimiser_view{std::move(urange1), window_size}
    {}

    /*!\brief Construct from two views and a given number of values in one window.
    * \param[in] urange1     The first input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] urange2     The second input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] window_size The number of values in one window.
    */
    indexed_minimiser_view(urng1_t urange1, urng2_t urange2, size_t const window_size) :
        minimiser_view{std::move(urange1), std::move(urange2), window_size}
    {}

    /*!\brief Construct from two non-views that can be view-wrapped and a given number of values in one window.
    * \tparam other_urng1_t  The type of another urange. Must model std::ranges::viewable_range and be constructible
                             from urng1_t.
    * \tparam other_urng2_t  The type of another urange. Must model std::ranges::viewable_range and be constructible
                             from urng2_t.
    * \param[in] urange1     The input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] urange2     The second input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] window_size The number of values in one window.
    */
    template <typename other_urng1_t, typename other_urng2_t>
    //!\cond
        requires (std::ranges::viewable_range<other_urng1_t> &&
                  std::constructible_from<urng1_t, std::views::all_t<other_urng1_t>> &&
                  std::ranges::viewable_range<other_urng2_t> &&
                  std::constructible_from<urng2_t, std::views::all_t<other_urng2_t>>)
    //!\endcond
    indexed_minimiser_view(other_urng1_t && urange1, other_urng2_t && urange2, size_t const window_size) :
        minimiser_view{std::forward<other_urng1_t>(urange1), std::forward<other_urng2_t>(urange2), window_size}
    {}
    //!\}

    /*!\name Iterators
     * \{
     */
    /*!\brief Returns an iterator to the first element of the range.
     * \returns Iterator to the first element.
     *
     * \details
     *
     * ### Complexity
     *
     * Constant.
     *
     * ### Exceptions
     *
     * Strong exception guarantee.
     */
    basic_iterator<false> begin()
    {
        return basic_iterator<false>{std::ranges::begin(minimiser_view)};
    }

    //!\copydoc begin()
    basic_iterator<true> begin() const
    //!\cond
        requires const_iterable
    //!\endcond
    {
        return basic_iterator<true>{std::ranges::cbegin(minimiser_view)};
    }

    /*!\brief Returns an iterator to the element following the last element of the range.
     * \returns Iterator to the end.
     *
     * \details
     *
     * This element acts as a placeholder; attempting to dereference it results in undefined behaviour.
     *
     * ### Complexity
     *
     * Constant.
     *
     * ### Exceptions
     *
     * No-throw guarantee.
     */
    sentinel end() const
    {
        return {};
    }
    //!\}
};

//!\brief Iterator for calculating minimisers.
template <std::ranges::view urng1_t, std::ranges::view urng2_t>
template <bool const_range>
class indexed_minimiser_view<urng1_t, urng2_t>::basic_iterator
{
private:
    using minimiser_iterator_t = std::ranges::iterator_t<std::conditional_t<const_range, minimiser_view_t const, minimiser_view_t>>;
    minimiser_iterator_t minimiser_iterator;

    using underlying_iterator_t = std::remove_cvref_t<decltype(std::declval<minimiser_iterator_t &>().base())>;
    underlying_iterator_t begin_iterator;

    static_assert(std::sized_sentinel_for<underlying_iterator_t, underlying_iterator_t>, "We assume that the original hash-iterator have a difference operator.");

    template <bool>
    friend class basic_iterator;

    using underlying_val_t = std::iter_value_t<minimiser_iterator_t>;

public:
    /*!\name Associated types
     * \{
     */

    //!\brief Type for distances between iterators.
    using difference_type = std::iter_difference_t<minimiser_iterator_t>;
    //!\brief Value type of this iterator.
    using value_type = std::tuple<underlying_val_t, size_t>;

    //!\brief Reference to `value_type`.
    using reference = value_type;

    //!\brief The pointer type.
    using pointer = void;
    //!\brief Tag this class as a forward iterator.
    using iterator_category = std::forward_iterator_tag;
    //!\brief Tag this class as a forward iterator.
    using iterator_concept = iterator_category;
    //!\}

    /*!\name Constructors, destructor and assignment
     * \{
     */
    basic_iterator() = default; //!< Defaulted.
    basic_iterator(basic_iterator const &) = default; //!< Defaulted.
    basic_iterator(basic_iterator &&) = default; //!< Defaulted.
    basic_iterator & operator=(basic_iterator const &) = default; //!< Defaulted.
    basic_iterator & operator=(basic_iterator &&) = default; //!< Defaulted.
    ~basic_iterator() = default; //!< Defaulted.

    //!\brief Allow iterator on a const range to be constructible from an iterator over a non-const range.
    basic_iterator(basic_iterator<!const_range> const & it)
    //!\cond
        requires const_range
    //!\endcond
        : minimiser_iterator{it.minimiser_iterator},
          begin_iterator{it.begin_iterator}
    {}

    /*!\brief Construct from begin and end iterators of a given range over std::totally_ordered values, and the number
              of values per window.
    * \param[in] urng1_iterator Iterator pointing to the first position of the first std::totally_ordered range.
    * \param[in] urng1_sentinel Iterator pointing to the last position of the first std::totally_ordered range.
    * \param[in] urng2_iterator Iterator pointing to the first position of the second std::totally_ordered range.
    * \param[in] window_size The number of values in one window.
    *
    * \details
    *
    * Looks at the number of values per window in two ranges, returns the smallest between both as minimiser and
    * shifts then by one to repeat this action. If a minimiser in consecutive windows is the same, it is returned only
    * once.
    */
    explicit basic_iterator(minimiser_iterator_t minimiser_iterator) :
        minimiser_iterator{std::move(minimiser_iterator)},
        begin_iterator{this->minimiser_iterator.base()}
    {}
    //!\}

    //!\anchor basic_iterator_comparison
    //!\name Comparison operators
    //!\{

    //TODO: should the comparisons be between first and second of pair??
    //!\brief Compare to another basic_iterator.
    friend bool operator==(basic_iterator const & lhs, basic_iterator const & rhs)
    {
        return lhs.minimiser_iterator == rhs.minimiser_iterator;
    }

    //!\brief Compare to another basic_iterator.
    friend bool operator!=(basic_iterator const & lhs, basic_iterator const & rhs)
    {
        return !(lhs == rhs);
    }

    //!\brief Compare to the sentinel of the indexed_minimiser_view.
    friend bool operator==(basic_iterator const & lhs, sentinel const & rhs)
    {
        return lhs.minimiser_iterator == rhs;
    }

    //!\brief Compare to the sentinel of the indexed_minimiser_view.
    friend bool operator==(sentinel const & lhs, basic_iterator const & rhs)
    {
        return rhs == lhs;
    }

    //!\brief Compare to the sentinel of the indexed_minimiser_view.
    friend bool operator!=(sentinel const & lhs, basic_iterator const & rhs)
    {
        return !(lhs == rhs);
    }

    //!\brief Compare to the sentinel of the indexed_minimiser_view.
    friend bool operator!=(basic_iterator const & lhs, sentinel const & rhs)
    {
        return !(lhs == rhs);
    }
    //!\}

    //!\brief Pre-increment.
    basic_iterator & operator++() noexcept
    {
        ++minimiser_iterator;
        return *this;
    }

    //!\brief Post-increment.
    basic_iterator operator++(int) noexcept
    {
        basic_iterator tmp{*this};
        ++(*this);
        return tmp;
    }

    //!\brief Return the minimiser.
    reference operator*() const noexcept
    {
        return reference{*minimiser_iterator, minimiser_iterator.base() - begin_iterator};
    }
};

//!\brief A deduction guide for the view class template.
template <std::ranges::viewable_range rng1_t>
indexed_minimiser_view(rng1_t &&, size_t const window_size) -> indexed_minimiser_view<std::views::all_t<rng1_t>>;

//!\brief A deduction guide for the view class template.
template <std::ranges::viewable_range rng1_t, std::ranges::viewable_range rng2_t>
indexed_minimiser_view(rng1_t &&, rng2_t &&, size_t const window_size) -> indexed_minimiser_view<std::views::all_t<rng1_t>,
                                                                                        std::views::all_t<rng2_t>>;

// ---------------------------------------------------------------------------------------------------------------------
// minimiser_fn (adaptor definition)
// ---------------------------------------------------------------------------------------------------------------------

//![adaptor_def]
//!\brief views::minimiser's range adaptor object type (non-closure).
struct minimiser_fn
{
    //!\brief Store the number of values in one window and return a range adaptor closure object.
    constexpr auto operator()(size_t const window_size) const
    {
        return seqan3::detail::adaptor_from_functor{*this, window_size};
    }

    /*!\brief Call the view's constructor with two arguments: the underlying view and an integer indicating how many
     *        values one window contains.
     * \tparam urng1_t        The type of the input range to process. Must model std::ranges::viewable_range.
     * \param[in] urange1     The input range to process. Must model std::ranges::viewable_range and
     *                        std::ranges::forward_range.
     * \param[in] window_size The number of values in one window.
     * \returns  A range of converted values.
     */
    template <std::ranges::range urng1_t>
    constexpr auto operator()(urng1_t && urange1, size_t const window_size) const
    {
        static_assert(std::ranges::viewable_range<urng1_t>,
                      "The range parameter to views::minimiser cannot be a temporary of a non-view range.");
        static_assert(std::ranges::forward_range<urng1_t>,
                      "The range parameter to views::minimiser must model std::ranges::forward_range.");

        if (window_size == 1) // Would just return urange1 without any changes
            throw std::invalid_argument{"The chosen window_size is not valid. "
                                        "Please choose a value greater than 1 or use two ranges."};

        return indexed_minimiser_view{urange1, window_size};
    }
};

inline constexpr auto minimiser = minimiser_fn{};

} // namespace valik
